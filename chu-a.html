<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i Luy·ªán √Çm A</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #ffe4e1; /* M√†u h·ªìng ph·∫•n */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
            background-image: url('data:image/svg+xml,%3Csvg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M50 0 L100 50 L50 100 L0 50 Z" fill="%23fff" opacity="0.2"/%3E%3C/svg%3E');
            background-size: 50px 50px;
        }

        .game-container {
            max-width: 600px;
            width: 100%;
            padding: 3rem 1.5rem;
            background-color: #fffaf0; /* M√†u kem */
            border-radius: 2rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 6px 6px rgba(0, 0, 0, 0.1);
            border: 5px solid #ff69b4; /* Vi·ªÅn h·ªìng ƒë·∫≠m */
            text-align: center;
            position: relative;
            z-index: 10;
        }
        
        .title {
            font-family: 'Pacifico', cursive;
            font-size: 2.5rem;
            color: #ff69b4;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 0 #fff;
        }

        .sentence-display {
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: #4b0082; /* T√≠m ƒë·∫≠m */
            padding: 1rem;
            background-color: #fff0f5; /* T√≠m nh·∫°t */
            border-radius: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            border: 2px dashed #ffb6c1; /* Vi·ªÅn n√©t ƒë·ª©t */
            line-height: 1.5;
            transition: transform 0.3s ease-in-out;
            flex-wrap: wrap; /* Cho ph√©p c√°c t·ª´ xu·ªëng d√≤ng */
            justify-content: center; /* Gi·ªØ c√°c t·ª´ ·ªü gi·ªØa */
        }

        .sentence-display span {
            display: inline-block;
        }

        .sentence-display:active {
            transform: scale(0.98);
        }

        .icon {
            margin: 0 0.5rem;
            font-size: 2.5rem;
            vertical-align: middle;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 2rem;
        }

        .btn {
            background-color: #ff69b4;
            color: white;
            padding: 0.75rem 1.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: 3px solid white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
            background-color: #ff1493;
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.08);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .read-btn {
            background-color: #90ee90; /* Xanh l√° nh·∫°t */
            color: #3cb371; /* Xanh l√° ƒë·∫≠m */
            font-size: 1.25rem;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 3px solid white;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            margin-top: 1rem;
            font-weight: bold;
        }
        
        .read-btn:hover:not(:disabled) {
            transform: scale(1.05);
            background-color: #3cb371;
            color: white;
        }

        .read-btn:active:not(:disabled) {
            transform: scale(1);
        }

        .read-btn:disabled {
            background-color: #ccc;
            color: #999;
            cursor: not-allowed;
        }

        .record-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .record-btn, .playback-btn {
            background-color: #87ceeb; /* Sky Blue */
            color: white;
            padding: 0.75rem 1.5rem;
            font-size: 1.25rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 3px solid white;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .record-btn.recording {
            background-color: #ff4500; /* Red-Orange */
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .counter {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ff69b4;
            text-shadow: 1px 1px 0 #fff;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff69b4;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .timer-container {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4b0082;
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .timer-btn {
            padding: 0.25rem 0.75rem;
            font-size: 1rem;
            background-color: #ffcc00;
            color: white;
            border-radius: 9999px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
            cursor: pointer;
        }

        .timer-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1 class="title">B√© H·ªçc √Çm A</h1>
        <div id="sentence-display" class="sentence-display"></div>
        <div class="controls">
            <button id="prev-btn" class="btn">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
                </svg>
            </button>
            <div id="counter" class="counter"></div>
            <button id="next-btn" class="btn">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                </svg>
            </button>
        </div>
        
        <div class="timer-container">
            <span id="timer-display"></span>
            <button id="stop-timer-btn" class="timer-btn">D·ª´ng l·∫°i</button>
        </div>

        <div class="record-controls">
            <button id="record-btn" class="record-btn">Ghi √¢m</button>
            <button id="playback-btn" class="playback-btn" disabled>Nghe l·∫°i</button>
        </div>

        <button id="read-aloud-btn" class="read-btn">
            ƒê·ªçc c√¢u vƒÉn (Gi·ªçng AI)
        </button>
    </div>

    <div id="loading-overlay" class="loading">
        <div class="loading-spinner"></div>
        <p class="mt-2 text-pink-500 font-bold">ƒêang t·∫£i...</p>
    </div>

    <script type="module">
        import { getAuth, signInAnonymously, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        
        // Constants
        const API_KEY = ""; 
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
        const LOADING_OVERLAY = document.getElementById('loading-overlay');
        const MAX_TIME = 120; // 120 seconds
        
        // Firebase initialization (required by the platform)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        
        async function authenticate() {
            try {
                const __initial_auth_token = typeof window.__initial_auth_token !== 'undefined' ? window.__initial_auth_token : undefined;
                if (__initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Firebase authentication successful.");
            } catch (error) {
                console.error("Firebase authentication failed:", error);
            }
        }
        
        // Data for the game (30 sentences)
        const sentences = [
            { text: "B√† v√† ba ra ga.", icons: ["üë¥", "üöÇ"] },
            { text: "C·∫£ nh√† ta ca h√°t.", icons: ["üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üé§"] },
            { text: "A, c√° ba sa v√† c√° l√°.", icons: ["üê†", "üçÉ"] },
            { text: "√îng b√†, ba m√° ta.", icons: ["üë¥üëµ", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶"] },
            { text: "Ba ƒë√£ ra xa, c·∫£ nh√† ta v·ªó tay.", icons: ["üñêÔ∏è", "üëè"] },
            { text: "G√† v√† c√° ƒëi ƒë√° banh.", icons: ["üêî", "‚öΩ"] },
            { text: "B√† mua qu√† c√°p.", icons: ["üéÅ", "üõçÔ∏è"] },
            { text: "A, ba l√°i xe ta.", icons: ["üë®‚Äçüëß", "üöó"] },
            { text: "C·∫£ nh√† ta ƒÉn c√° v√† c√†.", icons: ["üêü", "üç≤"] },
            { text: "Ba ra s√¢n bay xa.", icons: ["‚úàÔ∏è", "üó∫Ô∏è"] },
            { text: "G√† ta ra ƒÉn l√°.", icons: ["üêì", "üçÇ"] },
            { text: "C√° ƒë√£ b∆°i ra xa.", icons: ["üê†", "üåä"] },
            { text: "B√© ca h√°t b√†i ca ca.", icons: ["üé§", "üé∂"] },
            { text: "M√° ta ƒë√£ v·ªÅ nh√†.", icons: ["üë©‚Äçüëß", "üè†"] },
            { text: "Ch·ªã c·∫£ ra ta ga.", icons: ["üë©", "üöâ"] },
            { text: "G√† m√°i ƒë√£ ƒÉn c√†.", icons: ["üêî", "ü•ó"] },
            { text: "G√† m√°i v√† g√† tr·ªëng ra ao.", icons: ["üêì", "ü¶Ü"] },
            { text: "B√© ƒë√£ h·ªçc ba, m√°.", icons: ["üëß", "üë®‚Äçüë©‚Äçüëß"] },
            { text: "Ba mua b√°nh ch·∫£ v√† ch√† l√†.", icons: ["üç∞", "üçÆ"] },
            { text: "M√° l√†m g√† v√† c√°.", icons: ["üë©‚Äçüç≥", "üçΩÔ∏è"] },
            { text: "Ba v√† m√° ƒëi xa.", icons: ["üë´", "üó∫Ô∏è"] },
            { text: "Anh ƒë√£ ca m·ªôt b√†i ca.", icons: ["üé§", "üé∂"] },
            { text: "Ba l√°i xe t·∫£i ra xa.", icons: ["üöö", "üõ£Ô∏è"] },
            { text: "G√† m√°i v√† g√† con.", icons: ["üêî", "üê£"] },
            { text: "C·∫£ nh√† ta ra b√£i c√°t.", icons: ["üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üèñÔ∏è"] },
            { text: "Ba ƒë√£ mua g√† v√† c√°.", icons: ["üõí", "üêü"] },
            { text: "M√° ƒë√£ ra si√™u th·ªã xa.", icons: ["üõçÔ∏è", "üõí"] },
            { text: "G√† ta ƒë√£ ƒÉn l√° c√¢y.", icons: ["üêì", "üå≥"] },
            { text: "C√° ƒë√£ b∆°i ra xa h∆°n.", icons: ["üê†", "üèä"] },
            { text: "B√† ƒë√£ ra c·ª≠a h√†ng.", icons: ["üëµ", "üè™"] }
        ];

        let currentSentenceIndex = 0;
        const totalSentences = sentences.length;

        // Audio for recording
        let mediaRecorder;
        let recordedAudioChunks = [];
        let recordedAudioBlob = null;
        let recording = false;
        
        // Timer
        let timer;
        let timeLeft = MAX_TIME;
        let timerRunning = true;

        // DOM elements
        const sentenceDisplay = document.getElementById('sentence-display');
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const readAloudBtn = document.getElementById('read-aloud-btn');
        const recordBtn = document.getElementById('record-btn');
        const playbackBtn = document.getElementById('playback-btn');
        const counter = document.getElementById('counter');
        const timerDisplay = document.getElementById('timer-display');
        const stopTimerBtn = document.getElementById('stop-timer-btn');

        // Functions
        function updateUI() {
            const currentSentence = sentences[currentSentenceIndex];
            sentenceDisplay.innerHTML = '';
            
            const words = currentSentence.text.split(' ');
            words.forEach((word, index) => {
                const span = document.createElement('span');
                span.textContent = word;
                sentenceDisplay.appendChild(span);

                if (index < words.length - 1) {
                    const iconIndex = index % currentSentence.icons.length;
                    const iconSpan = document.createElement('span');
                    iconSpan.textContent = currentSentence.icons[iconIndex];
                    iconSpan.classList.add('icon');
                    sentenceDisplay.appendChild(iconSpan);
                }
            });

            counter.textContent = `${currentSentenceIndex + 1}/${totalSentences}`;
            resetTimer();
        }

        function resetTimer() {
            clearInterval(timer);
            timeLeft = MAX_TIME;
            timerRunning = true;
            stopTimerBtn.textContent = 'D·ª´ng l·∫°i';
            timerDisplay.textContent = `Th·ªùi gian c√≤n l·∫°i: ${timeLeft}s`;
            timer = setInterval(() => {
                timeLeft--;
                timerDisplay.textContent = `Th·ªùi gian c√≤n l·∫°i: ${timeLeft}s`;
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    nextSentence();
                }
            }, 1000);
        }

        function toggleTimer() {
            if (timerRunning) {
                clearInterval(timer);
                stopTimerBtn.textContent = 'Ti·∫øp t·ª•c';
            } else {
                resetTimer();
            }
            timerRunning = !timerRunning;
        }

        // Sound effect for navigation
        function playCuteSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.value = 440;
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.warn("AudioContext not supported, can't play sound effect.");
            }
        }

        // --- Recording and Playback Logic ---

        // Asks for microphone permission and initializes MediaRecorder
        async function initRecorder() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                // Use a custom UI element for an alert instead of window.alert()
                console.error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ghi √¢m.');
                recordBtn.disabled = true;
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => {
                    recordedAudioChunks.push(event.data);
                };
                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(recordedAudioChunks, { type: 'audio/webm' });
                    playbackBtn.disabled = false;
                    recordBtn.textContent = 'Ghi √¢m l·∫°i';
                    recordBtn.classList.remove('recording');
                    recording = false;
                };
            } catch (err) {
                console.error(`Kh√¥ng th·ªÉ truy c·∫≠p microphone. Vui l√≤ng c·∫•p quy·ªÅn ghi √¢m.`);
                recordBtn.disabled = true;
            }
        }

        // Starts or stops the recording
        function toggleRecording() {
            if (!mediaRecorder) {
                console.error('Ch·ª©c nƒÉng ghi √¢m ch∆∞a s·∫µn s√†ng. Vui l√≤ng th·ª≠ l·∫°i.');
                return;
            }

            if (!recording) {
                recordedAudioChunks = [];
                mediaRecorder.start();
                recordBtn.textContent = 'ƒêang ghi √¢m...';
                recordBtn.classList.add('recording');
                playbackBtn.disabled = true;
                recording = true;
            } else {
                mediaRecorder.stop();
            }
        }
        
        // Plays back the recorded audio
        function playRecording() {
            if (recordedAudioBlob) {
                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                const audio = new Audio(audioUrl);
                audio.play();
            }
        }
        
        // --- AI TTS Logic ---
        
        function showLoading(show) {
            if (show) {
                LOADING_OVERLAY.style.display = 'flex';
                readAloudBtn.disabled = true;
                nextBtn.disabled = true;
                prevBtn.disabled = true;
            } else {
                LOADING_OVERLAY.style.display = 'none';
                readAloudBtn.disabled = false;
                nextBtn.disabled = false;
                prevBtn.disabled = false;
            }
        }
        
        async function readAloud() {
            showLoading(true);
            const textToRead = `ƒê·ªçc ch·∫≠m v√† r√µ r√†ng nh∆∞ m·ªôt ng∆∞·ªùi ƒëang k·ªÉ chuy·ªán: ${sentences[currentSentenceIndex].text}`;
            const payload = {
                contents: [{
                    parts: [{ text: textToRead }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Charon" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            let retryCount = 0;
            const maxRetries = 5;
            let audioUrl = null;

            while (retryCount < maxRetries) {
                try {
                    const response = await fetch(`${API_URL}${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        if (response.status === 429) {
                            const delay = Math.pow(2, retryCount) * 1000;
                            retryCount++;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        } else {
                             console.error("API error:", response.status, response.statusText);
                            break;
                        }
                    }

                    const result = await response.json();
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        audioUrl = URL.createObjectURL(wavBlob);
                        const audio = new Audio(audioUrl);
                        audio.play();
                    } else {
                        console.error("Invalid audio data from API.");
                    }
                    break; 

                } catch (error) {
                    console.error("Fetch error:", error);
                    break;
                }
            }
             showLoading(false);
        }

        // Helper functions for audio processing
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitDepth = 16;
            const pcmLength = pcmData.byteLength;
            const wavLength = pcmLength + 44;
            const buffer = new ArrayBuffer(wavLength);
            const view = new DataView(buffer);

            let offset = 0;

            // RIFF header
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, wavLength - 8, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;

            // FMT sub-chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; // Sub-chunk size
            view.setUint16(offset, 1, true); offset += 2; // Audio format (1 = PCM)
            view.setUint16(offset, numChannels, true); offset += 2;
            view.setUint32(offset, sampleRate, true); offset += 4;
            view.setUint32(offset, sampleRate * numChannels * (bitDepth / 8), true); offset += 4;
            view.setUint16(offset, numChannels * (bitDepth / 8), true); offset += 2;
            view.setUint16(offset, bitDepth, true); offset += 2;

            // DATA sub-chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcmLength, true); offset += 4;

            // Write PCM data
            const pcmView = new Uint8Array(pcmData.buffer);
            for (let i = 0; i < pcmLength; i++, offset++) {
                view.setUint8(offset, pcmView[i]);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        // Event handlers
        function nextSentence() {
            playCuteSound();
            currentSentenceIndex = (currentSentenceIndex + 1) % totalSentences;
            updateUI();
        }

        function prevSentence() {
            playCuteSound();
            currentSentenceIndex = (currentSentenceIndex - 1 + totalSentences) % totalSentences;
            updateUI();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            updateUI();
            initRecorder();
            authenticate();
        });

        nextBtn.addEventListener('click', nextSentence);
        prevBtn.addEventListener('click', prevSentence);
        readAloudBtn.addEventListener('click', readAloud);
        recordBtn.addEventListener('click', toggleRecording);
        playbackBtn.addEventListener('click', playRecording);
        stopTimerBtn.addEventListener('click', toggleTimer);
    </script>
</body>
</html>
